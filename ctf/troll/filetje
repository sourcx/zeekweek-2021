         0.000000 spicy_analyzer_for_mime_type
                  [0] a: enum            = Files::ANALYZER_SPICY_ZIP
                  [1] mt: string         = application/zip

         0.000000 spicy_analyzer_for_mime_type
                  [0] a: enum            = Files::ANALYZER_SPICY_PE
                  [1] mt: string         = application/x-dosexec

         0.000000 spicy_analyzer_for_mime_type
                  [0] a: enum            = Files::ANALYZER_SPICY_PE
                  [1] mt: string         = application/x-dosexec

         0.000000 spicy_analyzer_for_mime_type
                  [0] a: enum            = Files::ANALYZER_SPICY_PNG
                  [1] mt: string         = image/png

         0.000000 zeek_init
local geladen
         0.000000 NetControl::init
         0.000000 filter_change_tracking
1626478454.779063 Broker::log_flush
1626478454.779063 ChecksumOffloading::check
1626478454.779063 filter_change_tracking
1626478454.779063 SumStats::finish_epoch
                  [0] ss: SumStats::SumStat = [name=detect-sqli-victims, epoch=5.0 mins, reducers={\x0a\x09[stream=http.sqli.victim, apply={\x0a\x09\x09SumStats::SUM,\x0a\x09\x09SumStats::SAMPLE\x0a\x09}, pred=<uninitialized>, normalize_key=<uninitialized>, ssname=<uninitialized>, calc_funcs=<uninitialized>, hll_error_margin=0.01, hll_confidence=0.95, num_last_elements=0, num_samples=5, topk_size=500, unique_max=<uninitialized>]\x0a}, threshold_val=lambda_<2631175753972287733>\x0a{ \x0areturn (HTTP::result[http.sqli.victim]$sum);\x0a}, threshold=50.0, threshold_series=<uninitialized>, threshold_crossed=lambda_<14750932826932128679>\x0a{ \x0aHTTP::r = HTTP::result[http.sqli.victim];\x0aNOTICE((coerce [$note=HTTP::SQL_Injection_Victim, $msg=An SQL injection victim was discovered!, $email_body_sections=vector(HTTP::format_sqli_samples(HTTP::r$samples)), $src=HTTP::key$host, $identifier=cat(HTTP::key$host)] to record { ts:time &log, &optional; uid:string &log, &optional; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; conn:record { id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }; orig:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; resp:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; start_time:time; duration:interval; service:set[string]; history:string; uid:string; tunnel:vector of record { cid:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; tunnel_type:enum Tunnel::Type &log; uid:string &optional, &log; } &optional; vlan:int &optional; inner_vlan:int &optional; dpd:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; analyzer:string &log; failure_reason:string &log; } &optional; dpd_state:record { violations:table[count] of count; } &optional; removal_hooks:set[hook(c:<recursion>;) : bool] &optional; conn:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; service:string &log, &optional; duration:interval &log, &optional; orig_bytes:count &log, &optional; resp_bytes:count &log, &optional; conn_state:string &log, &optional; local_orig:bool &log, &optional; local_resp:bool &log, &optional; missed_bytes:count &log, &default=0, &optional; history:string &log, &optional; orig_pkts:count &log, &optional; orig_ip_bytes:count &log, &optional; resp_pkts:count &log, &optional; resp_ip_bytes:count &log, &optional; tunnel_parents:set[string] &log, &optional; } &optional; extract_orig:bool &default=Conn::default_extract, &optional; extract_resp:bool &default=Conn::default_extract, &optional; thresholds:record { orig_byte:set[count] &default=set(), &optional; resp_byte:set[count] &default=set(), &optional; orig_packet:set[count] &default=set(), &optional; resp_packet:set[count] &default=set(), &optional; duration:set[interval] &default=set(), &optional; } &optional; dce_rpc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; } &optional; dce_rpc_state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; } &optional; dce_rpc_backing:table[count] of record { info:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; }; state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; }; } &optional; dhcp:record { ts:time &log; uids:set[string] &log; client_addr:addr &log, &optional; server_addr:addr &log, &optional; client_port:port &optional; server_port:port &optional; mac:string &log, &optional; host_name:string &log, &optional; client_fqdn:string &log, &optional; domain:string &log, &optional; requested_addr:addr &log, &optional; assigned_addr:addr &log, &optional; lease_time:interval &log, &optional; client_message:string &log, &optional; server_message:string &log, &optional; msg_types:vector of string &log, &default=vector(), &optional; duration:interval &log, &default=0 secs, &optional; client_chaddr:string &optional; last_message_ts:time &optional; } &optional; dnp3:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fc_request:string &log, &optional; fc_reply:string &log, &optional; iin:count &log, &optional; } &optional; dns:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; dns_state:record { pending_query:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; pending_queries:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; pending_replies:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; ftp_data_reuse:bool &default=F, &optional; ssl:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version_num:count &optional; version:string &log, &optional; cipher:string &log, &optional; curve:string &log, &optional; server_name:string &log, &optional; session_id:string &optional; resumed:bool &log, &default=F, &optional; client_ticket_empty_session_seen:bool &default=F, &optional; client_key_exchange_seen:bool &default=F, &optional; client_psk_seen:bool &default=F, &optional; last_alert:string &log, &optional; next_protocol:string &log, &optional; analyzer_id:count &optional; established:bool &log, &default=F, &optional; logged:bool &default=F, &optional; ssl_history:string &log, &default=, &optional; delay_tokens:set[string] &optional; cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; cert_chain_fps:vector of string &optional, &log; client_cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_chain_fps:vector of string &optional, &log; subject:string &log, &optional; issuer:string &log, &optional; client_subject:string &log, &optional; client_issuer:string &log, &optional; sni_matches_cert:bool &log, &optional; server_depth:count &default=0, &optional; client_depth:count &default=0, &optional; ja3:string &optional, &log; ja3_client:string &optional, &log; ja3s:string &optional, &log; ja3s_version:string &optional, &log; ja3s_cipher:string &optional, &log; ja3s_extensions:string &optional, &log; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; http_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; trans_depth:count &default=0, &optional; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; krb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; request_type:string &log, &optional; client:string &log, &optional; service:string &log, &optional; success:bool &log, &optional; error_code:count &optional; error_msg:string &log, &optional; from:time &log, &optional; till:time &log, &optional; cipher:string &log, &optional; forwardable:bool &log, &optional; renewable:bool &log, &optional; logged:bool &default=F, &optional; client_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_subject:string &log, &optional; client_cert_fuid:string &log, &optional; server_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; server_cert_subject:string &log, &optional; server_cert_fuid:string &log, &optional; } &optional; modbus:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; func:string &log, &optional; exception:string &log, &optional; } &optional; mysql:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cmd:string &log; arg:string &log; success:bool &log, &optional; rows:count &log, &optional; response:string &log, &optional; } &optional; ntlm:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; hostname:string &log, &optional; domainname:string &log, &optional; server_nb_computer_name:string &log, &optional; server_dns_computer_name:string &log, &optional; server_tree_name:string &log, &optional; success:bool &log, &optional; done:bool &default=F, &optional; } &optional; ntp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; mode:count &log; stratum:count &log; poll:interval &log; precision:interval &log; root_delay:interval &log; root_disp:interval &log; ref_id:string &log; ref_time:time &log; org_time:time &log; rec_time:time &log; xmt_time:time &log; num_exts:count &default=0, &optional, &log; } &optional; radius:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; mac:string &log, &optional; framed_addr:addr &log, &optional; tunnel_client:string &log, &optional; connect_info:string &log, &optional; reply_msg:string &log, &optional; result:string &log, &optional; ttl:interval &log, &optional; logged:bool &default=F, &optional; } &optional; rdp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cookie:string &log, &optional; result:string &log, &optional; security_protocol:string &log, &optional; client_channels:vector of string &log, &optional; keyboard_layout:string &log, &optional; client_build:string &log, &optional; client_name:string &log, &optional; client_dig_product_id:string &log, &optional; desktop_width:count &log, &optional; desktop_height:count &log, &optional; requested_color_depth:string &log, &optional; cert_type:string &log, &optional; cert_count:count &log, &default=0, &optional; cert_permanent:bool &log, &optional; encryption_level:string &log, &optional; encryption_method:string &log, &optional; analyzer_id:count &optional; done:bool &default=F, &optional; } &optional; rfb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; client_major_version:string &log, &optional; client_minor_version:string &log, &optional; server_major_version:string &log, &optional; server_minor_version:string &log, &optional; authentication_method:string &log, &optional; auth:bool &log, &optional; share_flag:bool &log, &optional; desktop_name:string &log, &optional; width:count &log, &optional; height:count &log, &optional; done:bool &default=F, &optional; } &optional; sip:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; } &optional; sip_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; } &optional; snmp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; duration:interval &log, &default=0 secs, &optional; version:string &log; community:string &log, &optional; get_requests:count &log, &default=0, &optional; get_bulk_requests:count &log, &default=0, &optional; get_responses:count &log, &default=0, &optional; set_requests:count &log, &default=0, &optional; display_string:string &log, &optional; up_since:time &log, &optional; } &optional; smb_state:record { current_cmd:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; current_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; current_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; pending_cmds:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; fid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; tid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; uid_map:table[count] of string &optional; pipe_map:table[count] of string &optional; recent_files:set[string] &default=set(), &optional, &read_expire=3.0 mins; } &optional; smtp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; } &optional; smtp_state:record { helo:string &optional; messages_transferred:count &default=0, &optional; pending_messages:set[record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; }] &optional; mime_depth:count &default=0, &optional; } &optional; socks:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; user:string &log, &optional; password:string &log, &optional; status:string &log, &optional; request:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; request_p:port &log, &optional; bound:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; bound_p:port &log, &optional; capture_password:bool &default=SOCKS::default_capture_password, &optional; } &optional; ssh:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log, &optional; auth_success:bool &log, &optional; auth_attempts:count &log, &default=0, &optional; direction:enum Direction &log, &optional; client:string &log, &optional; server:string &log, &optional; cipher_alg:string &log, &optional; mac_alg:string &log, &optional; compression_alg:string &log, &optional; kex_alg:string &log, &optional; host_key_alg:string &log, &optional; host_key:string &log, &optional; logged:bool &default=F, &optional; capabilities:record { kex_algorithms:vector of string; server_host_key_algorithms:vector of string; encryption_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; mac_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; compression_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; languages:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; } &optional; is_server:bool; } &optional; analyzer_id:count &optional; } &optional; syslog:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; facility:string &log; severity:string &log; message:string &log; } &optional; ja3fp:record { client_version:count &default=0, &optional, &log; client_ciphers:string &default=, &optional, &log; extensions:string &default=, &optional, &log; e_curves:string &default=, &optional, &log; ec_point_fmt:string &default=, &optional, &log; } &optional; ja3sfp:record { server_version:count &default=0, &optional, &log; server_cipher:count &default=0, &optional, &log; server_extensions:string &default=, &optional, &log; server_name:string &default=, &optional, &log; } &optional; } &optional; iconn:record { orig_h:addr; resp_h:addr; itype:count; icode:count; len:count; hlim:count; v6:bool; } &optional; f:record { id:string; parent_id:string &optional; source:string; is_orig:bool &optional; conns:table[record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }] of record { id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }; orig:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; resp:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; start_time:time; duration:interval; service:set[string]; history:string; uid:string; tunnel:vector of record { cid:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; tunnel_type:enum Tunnel::Type &log; uid:string &optional, &log; } &optional; vlan:int &optional; inner_vlan:int &optional; dpd:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; analyzer:string &log; failure_reason:string &log; } &optional; dpd_state:record { violations:table[count] of count; } &optional; removal_hooks:set[hook(c:<recursion>;) : bool] &optional; conn:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; service:string &log, &optional; duration:interval &log, &optional; orig_bytes:count &log, &optional; resp_bytes:count &log, &optional; conn_state:string &log, &optional; local_orig:bool &log, &optional; local_resp:bool &log, &optional; missed_bytes:count &log, &default=0, &optional; history:string &log, &optional; orig_pkts:count &log, &optional; orig_ip_bytes:count &log, &optional; resp_pkts:count &log, &optional; resp_ip_bytes:count &log, &optional; tunnel_parents:set[string] &log, &optional; } &optional; extract_orig:bool &default=Conn::default_extract, &optional; extract_resp:bool &default=Conn::default_extract, &optional; thresholds:record { orig_byte:set[count] &default=set(), &optional; resp_byte:set[count] &default=set(), &optional; orig_packet:set[count] &default=set(), &optional; resp_packet:set[count] &default=set(), &optional; duration:set[interval] &default=set(), &optional; } &optional; dce_rpc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; } &optional; dce_rpc_state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; } &optional; dce_rpc_backing:table[count] of record { info:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; }; state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; }; } &optional; dhcp:record { ts:time &log; uids:set[string] &log; client_addr:addr &log, &optional; server_addr:addr &log, &optional; client_port:port &optional; server_port:port &optional; mac:string &log, &optional; host_name:string &log, &optional; client_fqdn:string &log, &optional; domain:string &log, &optional; requested_addr:addr &log, &optional; assigned_addr:addr &log, &optional; lease_time:interval &log, &optional; client_message:string &log, &optional; server_message:string &log, &optional; msg_types:vector of string &log, &default=vector(), &optional; duration:interval &log, &default=0 secs, &optional; client_chaddr:string &optional; last_message_ts:time &optional; } &optional; dnp3:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fc_request:string &log, &optional; fc_reply:string &log, &optional; iin:count &log, &optional; } &optional; dns:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; dns_state:record { pending_query:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; pending_queries:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; pending_replies:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; ftp_data_reuse:bool &default=F, &optional; ssl:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version_num:count &optional; version:string &log, &optional; cipher:string &log, &optional; curve:string &log, &optional; server_name:string &log, &optional; session_id:string &optional; resumed:bool &log, &default=F, &optional; client_ticket_empty_session_seen:bool &default=F, &optional; client_key_exchange_seen:bool &default=F, &optional; client_psk_seen:bool &default=F, &optional; last_alert:string &log, &optional; next_protocol:string &log, &optional; analyzer_id:count &optional; established:bool &log, &default=F, &optional; logged:bool &default=F, &optional; ssl_history:string &log, &default=, &optional; delay_tokens:set[string] &optional; cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; cert_chain_fps:vector of string &optional, &log; client_cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_chain_fps:vector of string &optional, &log; subject:string &log, &optional; issuer:string &log, &optional; client_subject:string &log, &optional; client_issuer:string &log, &optional; sni_matches_cert:bool &log, &optional; server_depth:count &default=0, &optional; client_depth:count &default=0, &optional; ja3:string &optional, &log; ja3_client:string &optional, &log; ja3s:string &optional, &log; ja3s_version:string &optional, &log; ja3s_cipher:string &optional, &log; ja3s_extensions:string &optional, &log; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; http_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; trans_depth:count &default=0, &optional; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; krb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; request_type:string &log, &optional; client:string &log, &optional; service:string &log, &optional; success:bool &log, &optional; error_code:count &optional; error_msg:string &log, &optional; from:time &log, &optional; till:time &log, &optional; cipher:string &log, &optional; forwardable:bool &log, &optional; renewable:bool &log, &optional; logged:bool &default=F, &optional; client_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_subject:string &log, &optional; client_cert_fuid:string &log, &optional; server_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; server_cert_subject:string &log, &optional; server_cert_fuid:string &log, &optional; } &optional; modbus:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; func:string &log, &optional; exception:string &log, &optional; } &optional; mysql:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cmd:string &log; arg:string &log; success:bool &log, &optional; rows:count &log, &optional; response:string &log, &optional; } &optional; ntlm:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; hostname:string &log, &optional; domainname:string &log, &optional; server_nb_computer_name:string &log, &optional; server_dns_computer_name:string &log, &optional; server_tree_name:string &log, &optional; success:bool &log, &optional; done:bool &default=F, &optional; } &optional; ntp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; mode:count &log; stratum:count &log; poll:interval &log; precision:interval &log; root_delay:interval &log; root_disp:interval &log; ref_id:string &log; ref_time:time &log; org_time:time &log; rec_time:time &log; xmt_time:time &log; num_exts:count &default=0, &optional, &log; } &optional; radius:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; mac:string &log, &optional; framed_addr:addr &log, &optional; tunnel_client:string &log, &optional; connect_info:string &log, &optional; reply_msg:string &log, &optional; result:string &log, &optional; ttl:interval &log, &optional; logged:bool &default=F, &optional; } &optional; rdp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cookie:string &log, &optional; result:string &log, &optional; security_protocol:string &log, &optional; client_channels:vector of string &log, &optional; keyboard_layout:string &log, &optional; client_build:string &log, &optional; client_name:string &log, &optional; client_dig_product_id:string &log, &optional; desktop_width:count &log, &optional; desktop_height:count &log, &optional; requested_color_depth:string &log, &optional; cert_type:string &log, &optional; cert_count:count &log, &default=0, &optional; cert_permanent:bool &log, &optional; encryption_level:string &log, &optional; encryption_method:string &log, &optional; analyzer_id:count &optional; done:bool &default=F, &optional; } &optional; rfb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; client_major_version:string &log, &optional; client_minor_version:string &log, &optional; server_major_version:string &log, &optional; server_minor_version:string &log, &optional; authentication_method:string &log, &optional; auth:bool &log, &optional; share_flag:bool &log, &optional; desktop_name:string &log, &optional; width:count &log, &optional; height:count &log, &optional; done:bool &default=F, &optional; } &optional; sip:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; } &optional; sip_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; } &optional; snmp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; duration:interval &log, &default=0 secs, &optional; version:string &log; community:string &log, &optional; get_requests:count &log, &default=0, &optional; get_bulk_requests:count &log, &default=0, &optional; get_responses:count &log, &default=0, &optional; set_requests:count &log, &default=0, &optional; display_string:string &log, &optional; up_since:time &log, &optional; } &optional; smb_state:record { current_cmd:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; current_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; current_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; pending_cmds:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; fid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; tid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; uid_map:table[count] of string &optional; pipe_map:table[count] of string &optional; recent_files:set[string] &default=set(), &optional, &read_expire=3.0 mins; } &optional; smtp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; } &optional; smtp_state:record { helo:string &optional; messages_transferred:count &default=0, &optional; pending_messages:set[record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; }] &optional; mime_depth:count &default=0, &optional; } &optional; socks:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; user:string &log, &optional; password:string &log, &optional; status:string &log, &optional; request:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; request_p:port &log, &optional; bound:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; bound_p:port &log, &optional; capture_password:bool &default=SOCKS::default_capture_password, &optional; } &optional; ssh:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log, &optional; auth_success:bool &log, &optional; auth_attempts:count &log, &default=0, &optional; direction:enum Direction &log, &optional; client:string &log, &optional; server:string &log, &optional; cipher_alg:string &log, &optional; mac_alg:string &log, &optional; compression_alg:string &log, &optional; kex_alg:string &log, &optional; host_key_alg:string &log, &optional; host_key:string &log, &optional; logged:bool &default=F, &optional; capabilities:record { kex_algorithms:vector of string; server_host_key_algorithms:vector of string; encryption_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; mac_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; compression_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; languages:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; } &optional; is_server:bool; } &optional; analyzer_id:count &optional; } &optional; syslog:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; facility:string &log; severity:string &log; message:string &log; } &optional; ja3fp:record { client_version:count &default=0, &optional, &log; client_ciphers:string &default=, &optional, &log; extensions:string &default=, &optional, &log; e_curves:string &default=, &optional, &log; ec_point_fmt:string &default=, &optional, &log; } &optional; ja3sfp:record { server_version:count &default=0, &optional, &log; server_cipher:count &default=0, &optional, &log; server_extensions:string &default=, &optional, &log; server_name:string &default=, &optional, &log; } &optional; } &optional; last_active:time; seen_bytes:count &default=0, &optional; total_bytes:count &optional; missing_bytes:count &default=0, &optional; overflow_bytes:count &default=0, &optional; timeout_interval:interval &default=default_file_timeout_interval, &optional; bof_buffer_size:count &default=default_file_bof_buffer_size, &optional; bof_buffer:string &optional; info:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; pe:record { ts:time &log; id:string &log; machine:string &log, &optional; compile_ts:time &log, &optional; os:string &log, &optional; subsystem:string &log, &optional; is_exe:bool &log, &default=T, &optional; is_64bit:bool &log, &default=T, &optional; uses_aslr:bool &log, &default=F, &optional; uses_dep:bool &log, &default=F, &optional; uses_code_integrity:bool &log, &default=F, &optional; uses_seh:bool &log, &default=T, &optional; has_import_table:bool &log, &optional; has_export_table:bool &log, &optional; has_cert_table:bool &log, &optional; has_debug_data:bool &log, &optional; section_names:vector of string &log, &optional; } &optional; } &optional; fuid:string &log, &optional; file_mime_type:string &log, &optional; file_desc:string &log, &optional; proto:enum transport_proto &log, &optional; note:enum Notice::Type &log; msg:string &log, &optional; sub:string &log, &optional; src:addr &log, &optional; dst:addr &log, &optional; p:port &log, &optional; n:count &log, &optional; peer_name:string &optional; peer_descr:string &log, &optional; actions:set[enum Notice::Action] &log, &default=set(), &optional; email_dest:set[string] &log, &default=(coerce set() to set[string]), &optional; email_body_sections:vector of string &optional; email_delay_tokens:set[string] &optional; identifier:string &optional; suppress_for:interval &log, &default=Notice::default_suppression_interval, &optional; remote_location:record { country_code:string &optional, &log; region:string &optional, &log; city:string &optional, &log; latitude:double &optional, &log; longitude:double &optional, &log; } &log, &optional; }));\x0a}, epoch_result=<uninitialized>, epoch_finished=<uninitialized>]

1626478454.779063 SumStats::finish_epoch
                  [0] ss: SumStats::SumStat = [name=detect-sqli-attackers, epoch=5.0 mins, reducers={\x0a\x09[stream=http.sqli.attacker, apply={\x0a\x09\x09SumStats::SUM,\x0a\x09\x09SumStats::SAMPLE\x0a\x09}, pred=<uninitialized>, normalize_key=<uninitialized>, ssname=<uninitialized>, calc_funcs=<uninitialized>, hll_error_margin=0.01, hll_confidence=0.95, num_last_elements=0, num_samples=5, topk_size=500, unique_max=<uninitialized>]\x0a}, threshold_val=lambda_<11326156096465204338>\x0a{ \x0areturn (HTTP::result[http.sqli.attacker]$sum);\x0a}, threshold=50.0, threshold_series=<uninitialized>, threshold_crossed=lambda_<8872666557170573474>\x0a{ \x0aHTTP::r = HTTP::result[http.sqli.attacker];\x0aNOTICE((coerce [$note=HTTP::SQL_Injection_Attacker, $msg=An SQL injection attacker was discovered!, $email_body_sections=vector(HTTP::format_sqli_samples(HTTP::r$samples)), $src=HTTP::key$host, $identifier=cat(HTTP::key$host)] to record { ts:time &log, &optional; uid:string &log, &optional; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; conn:record { id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }; orig:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; resp:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; start_time:time; duration:interval; service:set[string]; history:string; uid:string; tunnel:vector of record { cid:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; tunnel_type:enum Tunnel::Type &log; uid:string &optional, &log; } &optional; vlan:int &optional; inner_vlan:int &optional; dpd:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; analyzer:string &log; failure_reason:string &log; } &optional; dpd_state:record { violations:table[count] of count; } &optional; removal_hooks:set[hook(c:<recursion>;) : bool] &optional; conn:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; service:string &log, &optional; duration:interval &log, &optional; orig_bytes:count &log, &optional; resp_bytes:count &log, &optional; conn_state:string &log, &optional; local_orig:bool &log, &optional; local_resp:bool &log, &optional; missed_bytes:count &log, &default=0, &optional; history:string &log, &optional; orig_pkts:count &log, &optional; orig_ip_bytes:count &log, &optional; resp_pkts:count &log, &optional; resp_ip_bytes:count &log, &optional; tunnel_parents:set[string] &log, &optional; } &optional; extract_orig:bool &default=Conn::default_extract, &optional; extract_resp:bool &default=Conn::default_extract, &optional; thresholds:record { orig_byte:set[count] &default=set(), &optional; resp_byte:set[count] &default=set(), &optional; orig_packet:set[count] &default=set(), &optional; resp_packet:set[count] &default=set(), &optional; duration:set[interval] &default=set(), &optional; } &optional; dce_rpc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; } &optional; dce_rpc_state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; } &optional; dce_rpc_backing:table[count] of record { info:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; }; state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; }; } &optional; dhcp:record { ts:time &log; uids:set[string] &log; client_addr:addr &log, &optional; server_addr:addr &log, &optional; client_port:port &optional; server_port:port &optional; mac:string &log, &optional; host_name:string &log, &optional; client_fqdn:string &log, &optional; domain:string &log, &optional; requested_addr:addr &log, &optional; assigned_addr:addr &log, &optional; lease_time:interval &log, &optional; client_message:string &log, &optional; server_message:string &log, &optional; msg_types:vector of string &log, &default=vector(), &optional; duration:interval &log, &default=0 secs, &optional; client_chaddr:string &optional; last_message_ts:time &optional; } &optional; dnp3:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fc_request:string &log, &optional; fc_reply:string &log, &optional; iin:count &log, &optional; } &optional; dns:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; dns_state:record { pending_query:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; pending_queries:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; pending_replies:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; ftp_data_reuse:bool &default=F, &optional; ssl:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version_num:count &optional; version:string &log, &optional; cipher:string &log, &optional; curve:string &log, &optional; server_name:string &log, &optional; session_id:string &optional; resumed:bool &log, &default=F, &optional; client_ticket_empty_session_seen:bool &default=F, &optional; client_key_exchange_seen:bool &default=F, &optional; client_psk_seen:bool &default=F, &optional; last_alert:string &log, &optional; next_protocol:string &log, &optional; analyzer_id:count &optional; established:bool &log, &default=F, &optional; logged:bool &default=F, &optional; ssl_history:string &log, &default=, &optional; delay_tokens:set[string] &optional; cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; cert_chain_fps:vector of string &optional, &log; client_cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_chain_fps:vector of string &optional, &log; subject:string &log, &optional; issuer:string &log, &optional; client_subject:string &log, &optional; client_issuer:string &log, &optional; sni_matches_cert:bool &log, &optional; server_depth:count &default=0, &optional; client_depth:count &default=0, &optional; ja3:string &optional, &log; ja3_client:string &optional, &log; ja3s:string &optional, &log; ja3s_version:string &optional, &log; ja3s_cipher:string &optional, &log; ja3s_extensions:string &optional, &log; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; http_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; trans_depth:count &default=0, &optional; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; krb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; request_type:string &log, &optional; client:string &log, &optional; service:string &log, &optional; success:bool &log, &optional; error_code:count &optional; error_msg:string &log, &optional; from:time &log, &optional; till:time &log, &optional; cipher:string &log, &optional; forwardable:bool &log, &optional; renewable:bool &log, &optional; logged:bool &default=F, &optional; client_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_subject:string &log, &optional; client_cert_fuid:string &log, &optional; server_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; server_cert_subject:string &log, &optional; server_cert_fuid:string &log, &optional; } &optional; modbus:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; func:string &log, &optional; exception:string &log, &optional; } &optional; mysql:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cmd:string &log; arg:string &log; success:bool &log, &optional; rows:count &log, &optional; response:string &log, &optional; } &optional; ntlm:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; hostname:string &log, &optional; domainname:string &log, &optional; server_nb_computer_name:string &log, &optional; server_dns_computer_name:string &log, &optional; server_tree_name:string &log, &optional; success:bool &log, &optional; done:bool &default=F, &optional; } &optional; ntp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; mode:count &log; stratum:count &log; poll:interval &log; precision:interval &log; root_delay:interval &log; root_disp:interval &log; ref_id:string &log; ref_time:time &log; org_time:time &log; rec_time:time &log; xmt_time:time &log; num_exts:count &default=0, &optional, &log; } &optional; radius:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; mac:string &log, &optional; framed_addr:addr &log, &optional; tunnel_client:string &log, &optional; connect_info:string &log, &optional; reply_msg:string &log, &optional; result:string &log, &optional; ttl:interval &log, &optional; logged:bool &default=F, &optional; } &optional; rdp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cookie:string &log, &optional; result:string &log, &optional; security_protocol:string &log, &optional; client_channels:vector of string &log, &optional; keyboard_layout:string &log, &optional; client_build:string &log, &optional; client_name:string &log, &optional; client_dig_product_id:string &log, &optional; desktop_width:count &log, &optional; desktop_height:count &log, &optional; requested_color_depth:string &log, &optional; cert_type:string &log, &optional; cert_count:count &log, &default=0, &optional; cert_permanent:bool &log, &optional; encryption_level:string &log, &optional; encryption_method:string &log, &optional; analyzer_id:count &optional; done:bool &default=F, &optional; } &optional; rfb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; client_major_version:string &log, &optional; client_minor_version:string &log, &optional; server_major_version:string &log, &optional; server_minor_version:string &log, &optional; authentication_method:string &log, &optional; auth:bool &log, &optional; share_flag:bool &log, &optional; desktop_name:string &log, &optional; width:count &log, &optional; height:count &log, &optional; done:bool &default=F, &optional; } &optional; sip:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; } &optional; sip_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; } &optional; snmp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; duration:interval &log, &default=0 secs, &optional; version:string &log; community:string &log, &optional; get_requests:count &log, &default=0, &optional; get_bulk_requests:count &log, &default=0, &optional; get_responses:count &log, &default=0, &optional; set_requests:count &log, &default=0, &optional; display_string:string &log, &optional; up_since:time &log, &optional; } &optional; smb_state:record { current_cmd:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; current_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; current_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; pending_cmds:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; fid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; tid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; uid_map:table[count] of string &optional; pipe_map:table[count] of string &optional; recent_files:set[string] &default=set(), &optional, &read_expire=3.0 mins; } &optional; smtp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; } &optional; smtp_state:record { helo:string &optional; messages_transferred:count &default=0, &optional; pending_messages:set[record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; }] &optional; mime_depth:count &default=0, &optional; } &optional; socks:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; user:string &log, &optional; password:string &log, &optional; status:string &log, &optional; request:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; request_p:port &log, &optional; bound:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; bound_p:port &log, &optional; capture_password:bool &default=SOCKS::default_capture_password, &optional; } &optional; ssh:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log, &optional; auth_success:bool &log, &optional; auth_attempts:count &log, &default=0, &optional; direction:enum Direction &log, &optional; client:string &log, &optional; server:string &log, &optional; cipher_alg:string &log, &optional; mac_alg:string &log, &optional; compression_alg:string &log, &optional; kex_alg:string &log, &optional; host_key_alg:string &log, &optional; host_key:string &log, &optional; logged:bool &default=F, &optional; capabilities:record { kex_algorithms:vector of string; server_host_key_algorithms:vector of string; encryption_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; mac_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; compression_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; languages:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; } &optional; is_server:bool; } &optional; analyzer_id:count &optional; } &optional; syslog:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; facility:string &log; severity:string &log; message:string &log; } &optional; ja3fp:record { client_version:count &default=0, &optional, &log; client_ciphers:string &default=, &optional, &log; extensions:string &default=, &optional, &log; e_curves:string &default=, &optional, &log; ec_point_fmt:string &default=, &optional, &log; } &optional; ja3sfp:record { server_version:count &default=0, &optional, &log; server_cipher:count &default=0, &optional, &log; server_extensions:string &default=, &optional, &log; server_name:string &default=, &optional, &log; } &optional; } &optional; iconn:record { orig_h:addr; resp_h:addr; itype:count; icode:count; len:count; hlim:count; v6:bool; } &optional; f:record { id:string; parent_id:string &optional; source:string; is_orig:bool &optional; conns:table[record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }] of record { id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }; orig:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; resp:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; start_time:time; duration:interval; service:set[string]; history:string; uid:string; tunnel:vector of record { cid:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; tunnel_type:enum Tunnel::Type &log; uid:string &optional, &log; } &optional; vlan:int &optional; inner_vlan:int &optional; dpd:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; analyzer:string &log; failure_reason:string &log; } &optional; dpd_state:record { violations:table[count] of count; } &optional; removal_hooks:set[hook(c:<recursion>;) : bool] &optional; conn:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; service:string &log, &optional; duration:interval &log, &optional; orig_bytes:count &log, &optional; resp_bytes:count &log, &optional; conn_state:string &log, &optional; local_orig:bool &log, &optional; local_resp:bool &log, &optional; missed_bytes:count &log, &default=0, &optional; history:string &log, &optional; orig_pkts:count &log, &optional; orig_ip_bytes:count &log, &optional; resp_pkts:count &log, &optional; resp_ip_bytes:count &log, &optional; tunnel_parents:set[string] &log, &optional; } &optional; extract_orig:bool &default=Conn::default_extract, &optional; extract_resp:bool &default=Conn::default_extract, &optional; thresholds:record { orig_byte:set[count] &default=set(), &optional; resp_byte:set[count] &default=set(), &optional; orig_packet:set[count] &default=set(), &optional; resp_packet:set[count] &default=set(), &optional; duration:set[interval] &default=set(), &optional; } &optional; dce_rpc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; } &optional; dce_rpc_state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; } &optional; dce_rpc_backing:table[count] of record { info:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; }; state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; }; } &optional; dhcp:record { ts:time &log; uids:set[string] &log; client_addr:addr &log, &optional; server_addr:addr &log, &optional; client_port:port &optional; server_port:port &optional; mac:string &log, &optional; host_name:string &log, &optional; client_fqdn:string &log, &optional; domain:string &log, &optional; requested_addr:addr &log, &optional; assigned_addr:addr &log, &optional; lease_time:interval &log, &optional; client_message:string &log, &optional; server_message:string &log, &optional; msg_types:vector of string &log, &default=vector(), &optional; duration:interval &log, &default=0 secs, &optional; client_chaddr:string &optional; last_message_ts:time &optional; } &optional; dnp3:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fc_request:string &log, &optional; fc_reply:string &log, &optional; iin:count &log, &optional; } &optional; dns:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; dns_state:record { pending_query:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; pending_queries:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; pending_replies:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; ftp_data_reuse:bool &default=F, &optional; ssl:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version_num:count &optional; version:string &log, &optional; cipher:string &log, &optional; curve:string &log, &optional; server_name:string &log, &optional; session_id:string &optional; resumed:bool &log, &default=F, &optional; client_ticket_empty_session_seen:bool &default=F, &optional; client_key_exchange_seen:bool &default=F, &optional; client_psk_seen:bool &default=F, &optional; last_alert:string &log, &optional; next_protocol:string &log, &optional; analyzer_id:count &optional; established:bool &log, &default=F, &optional; logged:bool &default=F, &optional; ssl_history:string &log, &default=, &optional; delay_tokens:set[string] &optional; cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; cert_chain_fps:vector of string &optional, &log; client_cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_chain_fps:vector of string &optional, &log; subject:string &log, &optional; issuer:string &log, &optional; client_subject:string &log, &optional; client_issuer:string &log, &optional; sni_matches_cert:bool &log, &optional; server_depth:count &default=0, &optional; client_depth:count &default=0, &optional; ja3:string &optional, &log; ja3_client:string &optional, &log; ja3s:string &optional, &log; ja3s_version:string &optional, &log; ja3s_cipher:string &optional, &log; ja3s_extensions:string &optional, &log; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; http_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; trans_depth:count &default=0, &optional; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; krb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; request_type:string &log, &optional; client:string &log, &optional; service:string &log, &optional; success:bool &log, &optional; error_code:count &optional; error_msg:string &log, &optional; from:time &log, &optional; till:time &log, &optional; cipher:string &log, &optional; forwardable:bool &log, &optional; renewable:bool &log, &optional; logged:bool &default=F, &optional; client_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_subject:string &log, &optional; client_cert_fuid:string &log, &optional; server_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; server_cert_subject:string &log, &optional; server_cert_fuid:string &log, &optional; } &optional; modbus:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; func:string &log, &optional; exception:string &log, &optional; } &optional; mysql:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cmd:string &log; arg:string &log; success:bool &log, &optional; rows:count &log, &optional; response:string &log, &optional; } &optional; ntlm:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; hostname:string &log, &optional; domainname:string &log, &optional; server_nb_computer_name:string &log, &optional; server_dns_computer_name:string &log, &optional; server_tree_name:string &log, &optional; success:bool &log, &optional; done:bool &default=F, &optional; } &optional; ntp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; mode:count &log; stratum:count &log; poll:interval &log; precision:interval &log; root_delay:interval &log; root_disp:interval &log; ref_id:string &log; ref_time:time &log; org_time:time &log; rec_time:time &log; xmt_time:time &log; num_exts:count &default=0, &optional, &log; } &optional; radius:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; mac:string &log, &optional; framed_addr:addr &log, &optional; tunnel_client:string &log, &optional; connect_info:string &log, &optional; reply_msg:string &log, &optional; result:string &log, &optional; ttl:interval &log, &optional; logged:bool &default=F, &optional; } &optional; rdp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cookie:string &log, &optional; result:string &log, &optional; security_protocol:string &log, &optional; client_channels:vector of string &log, &optional; keyboard_layout:string &log, &optional; client_build:string &log, &optional; client_name:string &log, &optional; client_dig_product_id:string &log, &optional; desktop_width:count &log, &optional; desktop_height:count &log, &optional; requested_color_depth:string &log, &optional; cert_type:string &log, &optional; cert_count:count &log, &default=0, &optional; cert_permanent:bool &log, &optional; encryption_level:string &log, &optional; encryption_method:string &log, &optional; analyzer_id:count &optional; done:bool &default=F, &optional; } &optional; rfb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; client_major_version:string &log, &optional; client_minor_version:string &log, &optional; server_major_version:string &log, &optional; server_minor_version:string &log, &optional; authentication_method:string &log, &optional; auth:bool &log, &optional; share_flag:bool &log, &optional; desktop_name:string &log, &optional; width:count &log, &optional; height:count &log, &optional; done:bool &default=F, &optional; } &optional; sip:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; } &optional; sip_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; } &optional; snmp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; duration:interval &log, &default=0 secs, &optional; version:string &log; community:string &log, &optional; get_requests:count &log, &default=0, &optional; get_bulk_requests:count &log, &default=0, &optional; get_responses:count &log, &default=0, &optional; set_requests:count &log, &default=0, &optional; display_string:string &log, &optional; up_since:time &log, &optional; } &optional; smb_state:record { current_cmd:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; current_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; current_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; pending_cmds:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; fid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; tid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; uid_map:table[count] of string &optional; pipe_map:table[count] of string &optional; recent_files:set[string] &default=set(), &optional, &read_expire=3.0 mins; } &optional; smtp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; } &optional; smtp_state:record { helo:string &optional; messages_transferred:count &default=0, &optional; pending_messages:set[record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; }] &optional; mime_depth:count &default=0, &optional; } &optional; socks:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; user:string &log, &optional; password:string &log, &optional; status:string &log, &optional; request:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; request_p:port &log, &optional; bound:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; bound_p:port &log, &optional; capture_password:bool &default=SOCKS::default_capture_password, &optional; } &optional; ssh:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log, &optional; auth_success:bool &log, &optional; auth_attempts:count &log, &default=0, &optional; direction:enum Direction &log, &optional; client:string &log, &optional; server:string &log, &optional; cipher_alg:string &log, &optional; mac_alg:string &log, &optional; compression_alg:string &log, &optional; kex_alg:string &log, &optional; host_key_alg:string &log, &optional; host_key:string &log, &optional; logged:bool &default=F, &optional; capabilities:record { kex_algorithms:vector of string; server_host_key_algorithms:vector of string; encryption_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; mac_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; compression_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; languages:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; } &optional; is_server:bool; } &optional; analyzer_id:count &optional; } &optional; syslog:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; facility:string &log; severity:string &log; message:string &log; } &optional; ja3fp:record { client_version:count &default=0, &optional, &log; client_ciphers:string &default=, &optional, &log; extensions:string &default=, &optional, &log; e_curves:string &default=, &optional, &log; ec_point_fmt:string &default=, &optional, &log; } &optional; ja3sfp:record { server_version:count &default=0, &optional, &log; server_cipher:count &default=0, &optional, &log; server_extensions:string &default=, &optional, &log; server_name:string &default=, &optional, &log; } &optional; } &optional; last_active:time; seen_bytes:count &default=0, &optional; total_bytes:count &optional; missing_bytes:count &default=0, &optional; overflow_bytes:count &default=0, &optional; timeout_interval:interval &default=default_file_timeout_interval, &optional; bof_buffer_size:count &default=default_file_bof_buffer_size, &optional; bof_buffer:string &optional; info:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; pe:record { ts:time &log; id:string &log; machine:string &log, &optional; compile_ts:time &log, &optional; os:string &log, &optional; subsystem:string &log, &optional; is_exe:bool &log, &default=T, &optional; is_64bit:bool &log, &default=T, &optional; uses_aslr:bool &log, &default=F, &optional; uses_dep:bool &log, &default=F, &optional; uses_code_integrity:bool &log, &default=F, &optional; uses_seh:bool &log, &default=T, &optional; has_import_table:bool &log, &optional; has_export_table:bool &log, &optional; has_cert_table:bool &log, &optional; has_debug_data:bool &log, &optional; section_names:vector of string &log, &optional; } &optional; } &optional; fuid:string &log, &optional; file_mime_type:string &log, &optional; file_desc:string &log, &optional; proto:enum transport_proto &log, &optional; note:enum Notice::Type &log; msg:string &log, &optional; sub:string &log, &optional; src:addr &log, &optional; dst:addr &log, &optional; p:port &log, &optional; n:count &log, &optional; peer_name:string &optional; peer_descr:string &log, &optional; actions:set[enum Notice::Action] &log, &default=set(), &optional; email_dest:set[string] &log, &default=(coerce set() to set[string]), &optional; email_body_sections:vector of string &optional; email_delay_tokens:set[string] &optional; identifier:string &optional; suppress_for:interval &log, &default=Notice::default_suppression_interval, &optional; remote_location:record { country_code:string &optional, &log; region:string &optional, &log; city:string &optional, &log; latitude:double &optional, &log; longitude:double &optional, &log; } &log, &optional; }));\x0a}, epoch_result=<uninitialized>, epoch_finished=<uninitialized>]

1626478458.040242 Broker::log_flush
1626478462.435464 Broker::log_flush
1626478462.435507 net_done
                  [0] t: time            = 1626478462.435507

1626478462.435507 Broker::log_flush
1626478462.435507 ChecksumOffloading::check
1626478462.435507 filter_change_tracking
1626478462.435507 SumStats::finish_epoch
                  [0] ss: SumStats::SumStat = [name=detect-sqli-victims, epoch=5.0 mins, reducers={\x0a\x09[stream=http.sqli.victim, apply={\x0a\x09\x09SumStats::SUM,\x0a\x09\x09SumStats::SAMPLE\x0a\x09}, pred=<uninitialized>, normalize_key=<uninitialized>, ssname=<uninitialized>, calc_funcs=<uninitialized>, hll_error_margin=0.01, hll_confidence=0.95, num_last_elements=0, num_samples=5, topk_size=500, unique_max=<uninitialized>]\x0a}, threshold_val=lambda_<2631175753972287733>\x0a{ \x0areturn (HTTP::result[http.sqli.victim]$sum);\x0a}, threshold=50.0, threshold_series=<uninitialized>, threshold_crossed=lambda_<14750932826932128679>\x0a{ \x0aHTTP::r = HTTP::result[http.sqli.victim];\x0aNOTICE((coerce [$note=HTTP::SQL_Injection_Victim, $msg=An SQL injection victim was discovered!, $email_body_sections=vector(HTTP::format_sqli_samples(HTTP::r$samples)), $src=HTTP::key$host, $identifier=cat(HTTP::key$host)] to record { ts:time &log, &optional; uid:string &log, &optional; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; conn:record { id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }; orig:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; resp:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; start_time:time; duration:interval; service:set[string]; history:string; uid:string; tunnel:vector of record { cid:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; tunnel_type:enum Tunnel::Type &log; uid:string &optional, &log; } &optional; vlan:int &optional; inner_vlan:int &optional; dpd:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; analyzer:string &log; failure_reason:string &log; } &optional; dpd_state:record { violations:table[count] of count; } &optional; removal_hooks:set[hook(c:<recursion>;) : bool] &optional; conn:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; service:string &log, &optional; duration:interval &log, &optional; orig_bytes:count &log, &optional; resp_bytes:count &log, &optional; conn_state:string &log, &optional; local_orig:bool &log, &optional; local_resp:bool &log, &optional; missed_bytes:count &log, &default=0, &optional; history:string &log, &optional; orig_pkts:count &log, &optional; orig_ip_bytes:count &log, &optional; resp_pkts:count &log, &optional; resp_ip_bytes:count &log, &optional; tunnel_parents:set[string] &log, &optional; } &optional; extract_orig:bool &default=Conn::default_extract, &optional; extract_resp:bool &default=Conn::default_extract, &optional; thresholds:record { orig_byte:set[count] &default=set(), &optional; resp_byte:set[count] &default=set(), &optional; orig_packet:set[count] &default=set(), &optional; resp_packet:set[count] &default=set(), &optional; duration:set[interval] &default=set(), &optional; } &optional; dce_rpc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; } &optional; dce_rpc_state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; } &optional; dce_rpc_backing:table[count] of record { info:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; }; state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; }; } &optional; dhcp:record { ts:time &log; uids:set[string] &log; client_addr:addr &log, &optional; server_addr:addr &log, &optional; client_port:port &optional; server_port:port &optional; mac:string &log, &optional; host_name:string &log, &optional; client_fqdn:string &log, &optional; domain:string &log, &optional; requested_addr:addr &log, &optional; assigned_addr:addr &log, &optional; lease_time:interval &log, &optional; client_message:string &log, &optional; server_message:string &log, &optional; msg_types:vector of string &log, &default=vector(), &optional; duration:interval &log, &default=0 secs, &optional; client_chaddr:string &optional; last_message_ts:time &optional; } &optional; dnp3:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fc_request:string &log, &optional; fc_reply:string &log, &optional; iin:count &log, &optional; } &optional; dns:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; dns_state:record { pending_query:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; pending_queries:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; pending_replies:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; ftp_data_reuse:bool &default=F, &optional; ssl:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version_num:count &optional; version:string &log, &optional; cipher:string &log, &optional; curve:string &log, &optional; server_name:string &log, &optional; session_id:string &optional; resumed:bool &log, &default=F, &optional; client_ticket_empty_session_seen:bool &default=F, &optional; client_key_exchange_seen:bool &default=F, &optional; client_psk_seen:bool &default=F, &optional; last_alert:string &log, &optional; next_protocol:string &log, &optional; analyzer_id:count &optional; established:bool &log, &default=F, &optional; logged:bool &default=F, &optional; ssl_history:string &log, &default=, &optional; delay_tokens:set[string] &optional; cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; cert_chain_fps:vector of string &optional, &log; client_cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_chain_fps:vector of string &optional, &log; subject:string &log, &optional; issuer:string &log, &optional; client_subject:string &log, &optional; client_issuer:string &log, &optional; sni_matches_cert:bool &log, &optional; server_depth:count &default=0, &optional; client_depth:count &default=0, &optional; ja3:string &optional, &log; ja3_client:string &optional, &log; ja3s:string &optional, &log; ja3s_version:string &optional, &log; ja3s_cipher:string &optional, &log; ja3s_extensions:string &optional, &log; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; http_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; trans_depth:count &default=0, &optional; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; krb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; request_type:string &log, &optional; client:string &log, &optional; service:string &log, &optional; success:bool &log, &optional; error_code:count &optional; error_msg:string &log, &optional; from:time &log, &optional; till:time &log, &optional; cipher:string &log, &optional; forwardable:bool &log, &optional; renewable:bool &log, &optional; logged:bool &default=F, &optional; client_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_subject:string &log, &optional; client_cert_fuid:string &log, &optional; server_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; server_cert_subject:string &log, &optional; server_cert_fuid:string &log, &optional; } &optional; modbus:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; func:string &log, &optional; exception:string &log, &optional; } &optional; mysql:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cmd:string &log; arg:string &log; success:bool &log, &optional; rows:count &log, &optional; response:string &log, &optional; } &optional; ntlm:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; hostname:string &log, &optional; domainname:string &log, &optional; server_nb_computer_name:string &log, &optional; server_dns_computer_name:string &log, &optional; server_tree_name:string &log, &optional; success:bool &log, &optional; done:bool &default=F, &optional; } &optional; ntp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; mode:count &log; stratum:count &log; poll:interval &log; precision:interval &log; root_delay:interval &log; root_disp:interval &log; ref_id:string &log; ref_time:time &log; org_time:time &log; rec_time:time &log; xmt_time:time &log; num_exts:count &default=0, &optional, &log; } &optional; radius:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; mac:string &log, &optional; framed_addr:addr &log, &optional; tunnel_client:string &log, &optional; connect_info:string &log, &optional; reply_msg:string &log, &optional; result:string &log, &optional; ttl:interval &log, &optional; logged:bool &default=F, &optional; } &optional; rdp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cookie:string &log, &optional; result:string &log, &optional; security_protocol:string &log, &optional; client_channels:vector of string &log, &optional; keyboard_layout:string &log, &optional; client_build:string &log, &optional; client_name:string &log, &optional; client_dig_product_id:string &log, &optional; desktop_width:count &log, &optional; desktop_height:count &log, &optional; requested_color_depth:string &log, &optional; cert_type:string &log, &optional; cert_count:count &log, &default=0, &optional; cert_permanent:bool &log, &optional; encryption_level:string &log, &optional; encryption_method:string &log, &optional; analyzer_id:count &optional; done:bool &default=F, &optional; } &optional; rfb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; client_major_version:string &log, &optional; client_minor_version:string &log, &optional; server_major_version:string &log, &optional; server_minor_version:string &log, &optional; authentication_method:string &log, &optional; auth:bool &log, &optional; share_flag:bool &log, &optional; desktop_name:string &log, &optional; width:count &log, &optional; height:count &log, &optional; done:bool &default=F, &optional; } &optional; sip:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; } &optional; sip_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; } &optional; snmp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; duration:interval &log, &default=0 secs, &optional; version:string &log; community:string &log, &optional; get_requests:count &log, &default=0, &optional; get_bulk_requests:count &log, &default=0, &optional; get_responses:count &log, &default=0, &optional; set_requests:count &log, &default=0, &optional; display_string:string &log, &optional; up_since:time &log, &optional; } &optional; smb_state:record { current_cmd:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; current_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; current_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; pending_cmds:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; fid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; tid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; uid_map:table[count] of string &optional; pipe_map:table[count] of string &optional; recent_files:set[string] &default=set(), &optional, &read_expire=3.0 mins; } &optional; smtp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; } &optional; smtp_state:record { helo:string &optional; messages_transferred:count &default=0, &optional; pending_messages:set[record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; }] &optional; mime_depth:count &default=0, &optional; } &optional; socks:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; user:string &log, &optional; password:string &log, &optional; status:string &log, &optional; request:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; request_p:port &log, &optional; bound:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; bound_p:port &log, &optional; capture_password:bool &default=SOCKS::default_capture_password, &optional; } &optional; ssh:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log, &optional; auth_success:bool &log, &optional; auth_attempts:count &log, &default=0, &optional; direction:enum Direction &log, &optional; client:string &log, &optional; server:string &log, &optional; cipher_alg:string &log, &optional; mac_alg:string &log, &optional; compression_alg:string &log, &optional; kex_alg:string &log, &optional; host_key_alg:string &log, &optional; host_key:string &log, &optional; logged:bool &default=F, &optional; capabilities:record { kex_algorithms:vector of string; server_host_key_algorithms:vector of string; encryption_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; mac_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; compression_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; languages:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; } &optional; is_server:bool; } &optional; analyzer_id:count &optional; } &optional; syslog:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; facility:string &log; severity:string &log; message:string &log; } &optional; ja3fp:record { client_version:count &default=0, &optional, &log; client_ciphers:string &default=, &optional, &log; extensions:string &default=, &optional, &log; e_curves:string &default=, &optional, &log; ec_point_fmt:string &default=, &optional, &log; } &optional; ja3sfp:record { server_version:count &default=0, &optional, &log; server_cipher:count &default=0, &optional, &log; server_extensions:string &default=, &optional, &log; server_name:string &default=, &optional, &log; } &optional; } &optional; iconn:record { orig_h:addr; resp_h:addr; itype:count; icode:count; len:count; hlim:count; v6:bool; } &optional; f:record { id:string; parent_id:string &optional; source:string; is_orig:bool &optional; conns:table[record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }] of record { id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }; orig:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; resp:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; start_time:time; duration:interval; service:set[string]; history:string; uid:string; tunnel:vector of record { cid:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; tunnel_type:enum Tunnel::Type &log; uid:string &optional, &log; } &optional; vlan:int &optional; inner_vlan:int &optional; dpd:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; analyzer:string &log; failure_reason:string &log; } &optional; dpd_state:record { violations:table[count] of count; } &optional; removal_hooks:set[hook(c:<recursion>;) : bool] &optional; conn:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; service:string &log, &optional; duration:interval &log, &optional; orig_bytes:count &log, &optional; resp_bytes:count &log, &optional; conn_state:string &log, &optional; local_orig:bool &log, &optional; local_resp:bool &log, &optional; missed_bytes:count &log, &default=0, &optional; history:string &log, &optional; orig_pkts:count &log, &optional; orig_ip_bytes:count &log, &optional; resp_pkts:count &log, &optional; resp_ip_bytes:count &log, &optional; tunnel_parents:set[string] &log, &optional; } &optional; extract_orig:bool &default=Conn::default_extract, &optional; extract_resp:bool &default=Conn::default_extract, &optional; thresholds:record { orig_byte:set[count] &default=set(), &optional; resp_byte:set[count] &default=set(), &optional; orig_packet:set[count] &default=set(), &optional; resp_packet:set[count] &default=set(), &optional; duration:set[interval] &default=set(), &optional; } &optional; dce_rpc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; } &optional; dce_rpc_state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; } &optional; dce_rpc_backing:table[count] of record { info:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; }; state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; }; } &optional; dhcp:record { ts:time &log; uids:set[string] &log; client_addr:addr &log, &optional; server_addr:addr &log, &optional; client_port:port &optional; server_port:port &optional; mac:string &log, &optional; host_name:string &log, &optional; client_fqdn:string &log, &optional; domain:string &log, &optional; requested_addr:addr &log, &optional; assigned_addr:addr &log, &optional; lease_time:interval &log, &optional; client_message:string &log, &optional; server_message:string &log, &optional; msg_types:vector of string &log, &default=vector(), &optional; duration:interval &log, &default=0 secs, &optional; client_chaddr:string &optional; last_message_ts:time &optional; } &optional; dnp3:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fc_request:string &log, &optional; fc_reply:string &log, &optional; iin:count &log, &optional; } &optional; dns:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; dns_state:record { pending_query:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; pending_queries:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; pending_replies:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; ftp_data_reuse:bool &default=F, &optional; ssl:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version_num:count &optional; version:string &log, &optional; cipher:string &log, &optional; curve:string &log, &optional; server_name:string &log, &optional; session_id:string &optional; resumed:bool &log, &default=F, &optional; client_ticket_empty_session_seen:bool &default=F, &optional; client_key_exchange_seen:bool &default=F, &optional; client_psk_seen:bool &default=F, &optional; last_alert:string &log, &optional; next_protocol:string &log, &optional; analyzer_id:count &optional; established:bool &log, &default=F, &optional; logged:bool &default=F, &optional; ssl_history:string &log, &default=, &optional; delay_tokens:set[string] &optional; cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; cert_chain_fps:vector of string &optional, &log; client_cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_chain_fps:vector of string &optional, &log; subject:string &log, &optional; issuer:string &log, &optional; client_subject:string &log, &optional; client_issuer:string &log, &optional; sni_matches_cert:bool &log, &optional; server_depth:count &default=0, &optional; client_depth:count &default=0, &optional; ja3:string &optional, &log; ja3_client:string &optional, &log; ja3s:string &optional, &log; ja3s_version:string &optional, &log; ja3s_cipher:string &optional, &log; ja3s_extensions:string &optional, &log; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; http_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; trans_depth:count &default=0, &optional; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; krb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; request_type:string &log, &optional; client:string &log, &optional; service:string &log, &optional; success:bool &log, &optional; error_code:count &optional; error_msg:string &log, &optional; from:time &log, &optional; till:time &log, &optional; cipher:string &log, &optional; forwardable:bool &log, &optional; renewable:bool &log, &optional; logged:bool &default=F, &optional; client_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_subject:string &log, &optional; client_cert_fuid:string &log, &optional; server_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; server_cert_subject:string &log, &optional; server_cert_fuid:string &log, &optional; } &optional; modbus:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; func:string &log, &optional; exception:string &log, &optional; } &optional; mysql:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cmd:string &log; arg:string &log; success:bool &log, &optional; rows:count &log, &optional; response:string &log, &optional; } &optional; ntlm:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; hostname:string &log, &optional; domainname:string &log, &optional; server_nb_computer_name:string &log, &optional; server_dns_computer_name:string &log, &optional; server_tree_name:string &log, &optional; success:bool &log, &optional; done:bool &default=F, &optional; } &optional; ntp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; mode:count &log; stratum:count &log; poll:interval &log; precision:interval &log; root_delay:interval &log; root_disp:interval &log; ref_id:string &log; ref_time:time &log; org_time:time &log; rec_time:time &log; xmt_time:time &log; num_exts:count &default=0, &optional, &log; } &optional; radius:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; mac:string &log, &optional; framed_addr:addr &log, &optional; tunnel_client:string &log, &optional; connect_info:string &log, &optional; reply_msg:string &log, &optional; result:string &log, &optional; ttl:interval &log, &optional; logged:bool &default=F, &optional; } &optional; rdp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cookie:string &log, &optional; result:string &log, &optional; security_protocol:string &log, &optional; client_channels:vector of string &log, &optional; keyboard_layout:string &log, &optional; client_build:string &log, &optional; client_name:string &log, &optional; client_dig_product_id:string &log, &optional; desktop_width:count &log, &optional; desktop_height:count &log, &optional; requested_color_depth:string &log, &optional; cert_type:string &log, &optional; cert_count:count &log, &default=0, &optional; cert_permanent:bool &log, &optional; encryption_level:string &log, &optional; encryption_method:string &log, &optional; analyzer_id:count &optional; done:bool &default=F, &optional; } &optional; rfb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; client_major_version:string &log, &optional; client_minor_version:string &log, &optional; server_major_version:string &log, &optional; server_minor_version:string &log, &optional; authentication_method:string &log, &optional; auth:bool &log, &optional; share_flag:bool &log, &optional; desktop_name:string &log, &optional; width:count &log, &optional; height:count &log, &optional; done:bool &default=F, &optional; } &optional; sip:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; } &optional; sip_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; } &optional; snmp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; duration:interval &log, &default=0 secs, &optional; version:string &log; community:string &log, &optional; get_requests:count &log, &default=0, &optional; get_bulk_requests:count &log, &default=0, &optional; get_responses:count &log, &default=0, &optional; set_requests:count &log, &default=0, &optional; display_string:string &log, &optional; up_since:time &log, &optional; } &optional; smb_state:record { current_cmd:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; current_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; current_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; pending_cmds:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; fid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; tid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; uid_map:table[count] of string &optional; pipe_map:table[count] of string &optional; recent_files:set[string] &default=set(), &optional, &read_expire=3.0 mins; } &optional; smtp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; } &optional; smtp_state:record { helo:string &optional; messages_transferred:count &default=0, &optional; pending_messages:set[record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; }] &optional; mime_depth:count &default=0, &optional; } &optional; socks:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; user:string &log, &optional; password:string &log, &optional; status:string &log, &optional; request:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; request_p:port &log, &optional; bound:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; bound_p:port &log, &optional; capture_password:bool &default=SOCKS::default_capture_password, &optional; } &optional; ssh:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log, &optional; auth_success:bool &log, &optional; auth_attempts:count &log, &default=0, &optional; direction:enum Direction &log, &optional; client:string &log, &optional; server:string &log, &optional; cipher_alg:string &log, &optional; mac_alg:string &log, &optional; compression_alg:string &log, &optional; kex_alg:string &log, &optional; host_key_alg:string &log, &optional; host_key:string &log, &optional; logged:bool &default=F, &optional; capabilities:record { kex_algorithms:vector of string; server_host_key_algorithms:vector of string; encryption_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; mac_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; compression_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; languages:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; } &optional; is_server:bool; } &optional; analyzer_id:count &optional; } &optional; syslog:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; facility:string &log; severity:string &log; message:string &log; } &optional; ja3fp:record { client_version:count &default=0, &optional, &log; client_ciphers:string &default=, &optional, &log; extensions:string &default=, &optional, &log; e_curves:string &default=, &optional, &log; ec_point_fmt:string &default=, &optional, &log; } &optional; ja3sfp:record { server_version:count &default=0, &optional, &log; server_cipher:count &default=0, &optional, &log; server_extensions:string &default=, &optional, &log; server_name:string &default=, &optional, &log; } &optional; } &optional; last_active:time; seen_bytes:count &default=0, &optional; total_bytes:count &optional; missing_bytes:count &default=0, &optional; overflow_bytes:count &default=0, &optional; timeout_interval:interval &default=default_file_timeout_interval, &optional; bof_buffer_size:count &default=default_file_bof_buffer_size, &optional; bof_buffer:string &optional; info:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; pe:record { ts:time &log; id:string &log; machine:string &log, &optional; compile_ts:time &log, &optional; os:string &log, &optional; subsystem:string &log, &optional; is_exe:bool &log, &default=T, &optional; is_64bit:bool &log, &default=T, &optional; uses_aslr:bool &log, &default=F, &optional; uses_dep:bool &log, &default=F, &optional; uses_code_integrity:bool &log, &default=F, &optional; uses_seh:bool &log, &default=T, &optional; has_import_table:bool &log, &optional; has_export_table:bool &log, &optional; has_cert_table:bool &log, &optional; has_debug_data:bool &log, &optional; section_names:vector of string &log, &optional; } &optional; } &optional; fuid:string &log, &optional; file_mime_type:string &log, &optional; file_desc:string &log, &optional; proto:enum transport_proto &log, &optional; note:enum Notice::Type &log; msg:string &log, &optional; sub:string &log, &optional; src:addr &log, &optional; dst:addr &log, &optional; p:port &log, &optional; n:count &log, &optional; peer_name:string &optional; peer_descr:string &log, &optional; actions:set[enum Notice::Action] &log, &default=set(), &optional; email_dest:set[string] &log, &default=(coerce set() to set[string]), &optional; email_body_sections:vector of string &optional; email_delay_tokens:set[string] &optional; identifier:string &optional; suppress_for:interval &log, &default=Notice::default_suppression_interval, &optional; remote_location:record { country_code:string &optional, &log; region:string &optional, &log; city:string &optional, &log; latitude:double &optional, &log; longitude:double &optional, &log; } &log, &optional; }));\x0a}, epoch_result=<uninitialized>, epoch_finished=<uninitialized>]

1626478462.435507 SumStats::finish_epoch
                  [0] ss: SumStats::SumStat = [name=detect-sqli-attackers, epoch=5.0 mins, reducers={\x0a\x09[stream=http.sqli.attacker, apply={\x0a\x09\x09SumStats::SUM,\x0a\x09\x09SumStats::SAMPLE\x0a\x09}, pred=<uninitialized>, normalize_key=<uninitialized>, ssname=<uninitialized>, calc_funcs=<uninitialized>, hll_error_margin=0.01, hll_confidence=0.95, num_last_elements=0, num_samples=5, topk_size=500, unique_max=<uninitialized>]\x0a}, threshold_val=lambda_<11326156096465204338>\x0a{ \x0areturn (HTTP::result[http.sqli.attacker]$sum);\x0a}, threshold=50.0, threshold_series=<uninitialized>, threshold_crossed=lambda_<8872666557170573474>\x0a{ \x0aHTTP::r = HTTP::result[http.sqli.attacker];\x0aNOTICE((coerce [$note=HTTP::SQL_Injection_Attacker, $msg=An SQL injection attacker was discovered!, $email_body_sections=vector(HTTP::format_sqli_samples(HTTP::r$samples)), $src=HTTP::key$host, $identifier=cat(HTTP::key$host)] to record { ts:time &log, &optional; uid:string &log, &optional; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; conn:record { id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }; orig:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; resp:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; start_time:time; duration:interval; service:set[string]; history:string; uid:string; tunnel:vector of record { cid:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; tunnel_type:enum Tunnel::Type &log; uid:string &optional, &log; } &optional; vlan:int &optional; inner_vlan:int &optional; dpd:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; analyzer:string &log; failure_reason:string &log; } &optional; dpd_state:record { violations:table[count] of count; } &optional; removal_hooks:set[hook(c:<recursion>;) : bool] &optional; conn:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; service:string &log, &optional; duration:interval &log, &optional; orig_bytes:count &log, &optional; resp_bytes:count &log, &optional; conn_state:string &log, &optional; local_orig:bool &log, &optional; local_resp:bool &log, &optional; missed_bytes:count &log, &default=0, &optional; history:string &log, &optional; orig_pkts:count &log, &optional; orig_ip_bytes:count &log, &optional; resp_pkts:count &log, &optional; resp_ip_bytes:count &log, &optional; tunnel_parents:set[string] &log, &optional; } &optional; extract_orig:bool &default=Conn::default_extract, &optional; extract_resp:bool &default=Conn::default_extract, &optional; thresholds:record { orig_byte:set[count] &default=set(), &optional; resp_byte:set[count] &default=set(), &optional; orig_packet:set[count] &default=set(), &optional; resp_packet:set[count] &default=set(), &optional; duration:set[interval] &default=set(), &optional; } &optional; dce_rpc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; } &optional; dce_rpc_state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; } &optional; dce_rpc_backing:table[count] of record { info:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; }; state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; }; } &optional; dhcp:record { ts:time &log; uids:set[string] &log; client_addr:addr &log, &optional; server_addr:addr &log, &optional; client_port:port &optional; server_port:port &optional; mac:string &log, &optional; host_name:string &log, &optional; client_fqdn:string &log, &optional; domain:string &log, &optional; requested_addr:addr &log, &optional; assigned_addr:addr &log, &optional; lease_time:interval &log, &optional; client_message:string &log, &optional; server_message:string &log, &optional; msg_types:vector of string &log, &default=vector(), &optional; duration:interval &log, &default=0 secs, &optional; client_chaddr:string &optional; last_message_ts:time &optional; } &optional; dnp3:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fc_request:string &log, &optional; fc_reply:string &log, &optional; iin:count &log, &optional; } &optional; dns:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; dns_state:record { pending_query:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; pending_queries:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; pending_replies:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; ftp_data_reuse:bool &default=F, &optional; ssl:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version_num:count &optional; version:string &log, &optional; cipher:string &log, &optional; curve:string &log, &optional; server_name:string &log, &optional; session_id:string &optional; resumed:bool &log, &default=F, &optional; client_ticket_empty_session_seen:bool &default=F, &optional; client_key_exchange_seen:bool &default=F, &optional; client_psk_seen:bool &default=F, &optional; last_alert:string &log, &optional; next_protocol:string &log, &optional; analyzer_id:count &optional; established:bool &log, &default=F, &optional; logged:bool &default=F, &optional; ssl_history:string &log, &default=, &optional; delay_tokens:set[string] &optional; cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; cert_chain_fps:vector of string &optional, &log; client_cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_chain_fps:vector of string &optional, &log; subject:string &log, &optional; issuer:string &log, &optional; client_subject:string &log, &optional; client_issuer:string &log, &optional; sni_matches_cert:bool &log, &optional; server_depth:count &default=0, &optional; client_depth:count &default=0, &optional; ja3:string &optional, &log; ja3_client:string &optional, &log; ja3s:string &optional, &log; ja3s_version:string &optional, &log; ja3s_cipher:string &optional, &log; ja3s_extensions:string &optional, &log; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; http_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; trans_depth:count &default=0, &optional; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; krb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; request_type:string &log, &optional; client:string &log, &optional; service:string &log, &optional; success:bool &log, &optional; error_code:count &optional; error_msg:string &log, &optional; from:time &log, &optional; till:time &log, &optional; cipher:string &log, &optional; forwardable:bool &log, &optional; renewable:bool &log, &optional; logged:bool &default=F, &optional; client_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_subject:string &log, &optional; client_cert_fuid:string &log, &optional; server_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; server_cert_subject:string &log, &optional; server_cert_fuid:string &log, &optional; } &optional; modbus:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; func:string &log, &optional; exception:string &log, &optional; } &optional; mysql:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cmd:string &log; arg:string &log; success:bool &log, &optional; rows:count &log, &optional; response:string &log, &optional; } &optional; ntlm:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; hostname:string &log, &optional; domainname:string &log, &optional; server_nb_computer_name:string &log, &optional; server_dns_computer_name:string &log, &optional; server_tree_name:string &log, &optional; success:bool &log, &optional; done:bool &default=F, &optional; } &optional; ntp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; mode:count &log; stratum:count &log; poll:interval &log; precision:interval &log; root_delay:interval &log; root_disp:interval &log; ref_id:string &log; ref_time:time &log; org_time:time &log; rec_time:time &log; xmt_time:time &log; num_exts:count &default=0, &optional, &log; } &optional; radius:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; mac:string &log, &optional; framed_addr:addr &log, &optional; tunnel_client:string &log, &optional; connect_info:string &log, &optional; reply_msg:string &log, &optional; result:string &log, &optional; ttl:interval &log, &optional; logged:bool &default=F, &optional; } &optional; rdp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cookie:string &log, &optional; result:string &log, &optional; security_protocol:string &log, &optional; client_channels:vector of string &log, &optional; keyboard_layout:string &log, &optional; client_build:string &log, &optional; client_name:string &log, &optional; client_dig_product_id:string &log, &optional; desktop_width:count &log, &optional; desktop_height:count &log, &optional; requested_color_depth:string &log, &optional; cert_type:string &log, &optional; cert_count:count &log, &default=0, &optional; cert_permanent:bool &log, &optional; encryption_level:string &log, &optional; encryption_method:string &log, &optional; analyzer_id:count &optional; done:bool &default=F, &optional; } &optional; rfb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; client_major_version:string &log, &optional; client_minor_version:string &log, &optional; server_major_version:string &log, &optional; server_minor_version:string &log, &optional; authentication_method:string &log, &optional; auth:bool &log, &optional; share_flag:bool &log, &optional; desktop_name:string &log, &optional; width:count &log, &optional; height:count &log, &optional; done:bool &default=F, &optional; } &optional; sip:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; } &optional; sip_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; } &optional; snmp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; duration:interval &log, &default=0 secs, &optional; version:string &log; community:string &log, &optional; get_requests:count &log, &default=0, &optional; get_bulk_requests:count &log, &default=0, &optional; get_responses:count &log, &default=0, &optional; set_requests:count &log, &default=0, &optional; display_string:string &log, &optional; up_since:time &log, &optional; } &optional; smb_state:record { current_cmd:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; current_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; current_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; pending_cmds:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; fid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; tid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; uid_map:table[count] of string &optional; pipe_map:table[count] of string &optional; recent_files:set[string] &default=set(), &optional, &read_expire=3.0 mins; } &optional; smtp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; } &optional; smtp_state:record { helo:string &optional; messages_transferred:count &default=0, &optional; pending_messages:set[record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; }] &optional; mime_depth:count &default=0, &optional; } &optional; socks:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; user:string &log, &optional; password:string &log, &optional; status:string &log, &optional; request:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; request_p:port &log, &optional; bound:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; bound_p:port &log, &optional; capture_password:bool &default=SOCKS::default_capture_password, &optional; } &optional; ssh:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log, &optional; auth_success:bool &log, &optional; auth_attempts:count &log, &default=0, &optional; direction:enum Direction &log, &optional; client:string &log, &optional; server:string &log, &optional; cipher_alg:string &log, &optional; mac_alg:string &log, &optional; compression_alg:string &log, &optional; kex_alg:string &log, &optional; host_key_alg:string &log, &optional; host_key:string &log, &optional; logged:bool &default=F, &optional; capabilities:record { kex_algorithms:vector of string; server_host_key_algorithms:vector of string; encryption_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; mac_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; compression_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; languages:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; } &optional; is_server:bool; } &optional; analyzer_id:count &optional; } &optional; syslog:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; facility:string &log; severity:string &log; message:string &log; } &optional; ja3fp:record { client_version:count &default=0, &optional, &log; client_ciphers:string &default=, &optional, &log; extensions:string &default=, &optional, &log; e_curves:string &default=, &optional, &log; ec_point_fmt:string &default=, &optional, &log; } &optional; ja3sfp:record { server_version:count &default=0, &optional, &log; server_cipher:count &default=0, &optional, &log; server_extensions:string &default=, &optional, &log; server_name:string &default=, &optional, &log; } &optional; } &optional; iconn:record { orig_h:addr; resp_h:addr; itype:count; icode:count; len:count; hlim:count; v6:bool; } &optional; f:record { id:string; parent_id:string &optional; source:string; is_orig:bool &optional; conns:table[record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }] of record { id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; }; orig:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; resp:record { size:count; state:count; num_pkts:count &optional; num_bytes_ip:count &optional; flow_label:count; l2_addr:string &optional; }; start_time:time; duration:interval; service:set[string]; history:string; uid:string; tunnel:vector of record { cid:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; tunnel_type:enum Tunnel::Type &log; uid:string &optional, &log; } &optional; vlan:int &optional; inner_vlan:int &optional; dpd:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; analyzer:string &log; failure_reason:string &log; } &optional; dpd_state:record { violations:table[count] of count; } &optional; removal_hooks:set[hook(c:<recursion>;) : bool] &optional; conn:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; service:string &log, &optional; duration:interval &log, &optional; orig_bytes:count &log, &optional; resp_bytes:count &log, &optional; conn_state:string &log, &optional; local_orig:bool &log, &optional; local_resp:bool &log, &optional; missed_bytes:count &log, &default=0, &optional; history:string &log, &optional; orig_pkts:count &log, &optional; orig_ip_bytes:count &log, &optional; resp_pkts:count &log, &optional; resp_ip_bytes:count &log, &optional; tunnel_parents:set[string] &log, &optional; } &optional; extract_orig:bool &default=Conn::default_extract, &optional; extract_resp:bool &default=Conn::default_extract, &optional; thresholds:record { orig_byte:set[count] &default=set(), &optional; resp_byte:set[count] &default=set(), &optional; orig_packet:set[count] &default=set(), &optional; resp_packet:set[count] &default=set(), &optional; duration:set[interval] &default=set(), &optional; } &optional; dce_rpc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; } &optional; dce_rpc_state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; } &optional; dce_rpc_backing:table[count] of record { info:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; rtt:interval &log, &optional; named_pipe:string &log, &optional; endpoint:string &log, &optional; operation:string &log, &optional; }; state:record { uuid:string &optional; named_pipe:string &optional; ctx_to_uuid:table[count] of string &optional; }; } &optional; dhcp:record { ts:time &log; uids:set[string] &log; client_addr:addr &log, &optional; server_addr:addr &log, &optional; client_port:port &optional; server_port:port &optional; mac:string &log, &optional; host_name:string &log, &optional; client_fqdn:string &log, &optional; domain:string &log, &optional; requested_addr:addr &log, &optional; assigned_addr:addr &log, &optional; lease_time:interval &log, &optional; client_message:string &log, &optional; server_message:string &log, &optional; msg_types:vector of string &log, &default=vector(), &optional; duration:interval &log, &default=0 secs, &optional; client_chaddr:string &optional; last_message_ts:time &optional; } &optional; dnp3:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fc_request:string &log, &optional; fc_reply:string &log, &optional; iin:count &log, &optional; } &optional; dns:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; dns_state:record { pending_query:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; trans_id:count &log, &optional; rtt:interval &log, &optional; query:string &log, &optional; qclass:count &log, &optional; qclass_name:string &log, &optional; qtype:count &log, &optional; qtype_name:string &log, &optional; rcode:count &log, &optional; rcode_name:string &log, &optional; AA:bool &log, &default=F, &optional; TC:bool &log, &default=F, &optional; RD:bool &log, &default=F, &optional; RA:bool &log, &default=F, &optional; Z:count &log, &default=0, &optional; answers:vector of string &log, &optional; TTLs:vector of interval &log, &optional; rejected:bool &log, &default=F, &optional; total_answers:count &optional; total_replies:count &optional; saw_query:bool &default=F, &optional; saw_reply:bool &default=F, &optional; } &optional; pending_queries:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; pending_replies:table[count] of record { initialized:bool &default=F, &optional; vals:table[count] of any &optional; settings:record { max_len:count &optional; } &optional; top:count &default=0, &optional; bottom:count &default=0, &optional; size:count &default=0, &optional; } &optional; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; ftp_data_reuse:bool &default=F, &optional; ssl:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version_num:count &optional; version:string &log, &optional; cipher:string &log, &optional; curve:string &log, &optional; server_name:string &log, &optional; session_id:string &optional; resumed:bool &log, &default=F, &optional; client_ticket_empty_session_seen:bool &default=F, &optional; client_key_exchange_seen:bool &default=F, &optional; client_psk_seen:bool &default=F, &optional; last_alert:string &log, &optional; next_protocol:string &log, &optional; analyzer_id:count &optional; established:bool &log, &default=F, &optional; logged:bool &default=F, &optional; ssl_history:string &log, &default=, &optional; delay_tokens:set[string] &optional; cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; cert_chain_fps:vector of string &optional, &log; client_cert_chain:vector of record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_chain_fps:vector of string &optional, &log; subject:string &log, &optional; issuer:string &log, &optional; client_subject:string &log, &optional; client_issuer:string &log, &optional; sni_matches_cert:bool &log, &optional; server_depth:count &default=0, &optional; client_depth:count &default=0, &optional; ja3:string &optional, &log; ja3_client:string &optional, &log; ja3s:string &optional, &log; ja3s_version:string &optional, &log; ja3s_cipher:string &optional, &log; ja3s_extensions:string &optional, &log; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; http_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; trans_depth:count &default=0, &optional; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; krb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; request_type:string &log, &optional; client:string &log, &optional; service:string &log, &optional; success:bool &log, &optional; error_code:count &optional; error_msg:string &log, &optional; from:time &log, &optional; till:time &log, &optional; cipher:string &log, &optional; forwardable:bool &log, &optional; renewable:bool &log, &optional; logged:bool &default=F, &optional; client_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; client_cert_subject:string &log, &optional; client_cert_fuid:string &log, &optional; server_cert:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; server_cert_subject:string &log, &optional; server_cert_fuid:string &log, &optional; } &optional; modbus:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; func:string &log, &optional; exception:string &log, &optional; } &optional; mysql:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cmd:string &log; arg:string &log; success:bool &log, &optional; rows:count &log, &optional; response:string &log, &optional; } &optional; ntlm:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; hostname:string &log, &optional; domainname:string &log, &optional; server_nb_computer_name:string &log, &optional; server_dns_computer_name:string &log, &optional; server_tree_name:string &log, &optional; success:bool &log, &optional; done:bool &default=F, &optional; } &optional; ntp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; mode:count &log; stratum:count &log; poll:interval &log; precision:interval &log; root_delay:interval &log; root_disp:interval &log; ref_id:string &log; ref_time:time &log; org_time:time &log; rec_time:time &log; xmt_time:time &log; num_exts:count &default=0, &optional, &log; } &optional; radius:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; username:string &log, &optional; mac:string &log, &optional; framed_addr:addr &log, &optional; tunnel_client:string &log, &optional; connect_info:string &log, &optional; reply_msg:string &log, &optional; result:string &log, &optional; ttl:interval &log, &optional; logged:bool &default=F, &optional; } &optional; rdp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; cookie:string &log, &optional; result:string &log, &optional; security_protocol:string &log, &optional; client_channels:vector of string &log, &optional; keyboard_layout:string &log, &optional; client_build:string &log, &optional; client_name:string &log, &optional; client_dig_product_id:string &log, &optional; desktop_width:count &log, &optional; desktop_height:count &log, &optional; requested_color_depth:string &log, &optional; cert_type:string &log, &optional; cert_count:count &log, &default=0, &optional; cert_permanent:bool &log, &optional; encryption_level:string &log, &optional; encryption_method:string &log, &optional; analyzer_id:count &optional; done:bool &default=F, &optional; } &optional; rfb:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; client_major_version:string &log, &optional; client_minor_version:string &log, &optional; server_major_version:string &log, &optional; server_minor_version:string &log, &optional; authentication_method:string &log, &optional; auth:bool &log, &optional; share_flag:bool &log, &optional; desktop_name:string &log, &optional; width:count &log, &optional; height:count &log, &optional; done:bool &default=F, &optional; } &optional; sip:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; } &optional; sip_state:record { pending:table[count] of record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; uri:string &log, &optional; date:string &log, &optional; request_from:string &log, &optional; request_to:string &log, &optional; response_from:string &log, &optional; response_to:string &log, &optional; reply_to:string &log, &optional; call_id:string &log, &optional; seq:string &log, &optional; subject:string &log, &optional; request_path:vector of string &log, &optional; response_path:vector of string &log, &optional; user_agent:string &log, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; warning:string &log, &optional; request_body_len:count &log, &optional; response_body_len:count &log, &optional; content_type:string &log, &optional; }; current_request:count &default=0, &optional; current_response:count &default=0, &optional; } &optional; snmp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; duration:interval &log, &default=0 secs, &optional; version:string &log; community:string &log, &optional; get_requests:count &log, &default=0, &optional; get_bulk_requests:count &log, &default=0, &optional; get_responses:count &log, &default=0, &optional; set_requests:count &log, &default=0, &optional; display_string:string &log, &optional; up_since:time &log, &optional; } &optional; smb_state:record { current_cmd:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; current_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; current_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; pending_cmds:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; command:string &log; sub_command:string &log, &optional; argument:string &log, &optional; status:string &log, &optional; rtt:interval &log, &optional; version:string &log; username:string &log, &optional; tree:string &log, &optional; tree_service:string &log, &optional; referenced_file:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &log, &optional; referenced_tree:record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; smb1_offered_dialects:vector of string &optional; smb2_offered_dialects:vector of count &optional; } &optional; fid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; fuid:string &log, &optional; action:enum SMB::Action &log, &optional; path:string &log, &optional; name:string &log, &optional; size:count &log, &default=0, &optional; prev_name:string &log, &optional; times:record { modified:time &log; modified_raw:count; accessed:time &log; accessed_raw:count; created:time &log; created_raw:count; changed:time &log; changed_raw:count; } &log, &optional; fid:count &optional; uuid:string &optional; } &optional; tid_map:table[count] of record { ts:time &log, &default=network_time(), &optional; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; path:string &log, &optional; service:string &log, &optional; native_file_system:string &log, &optional; share_type:string &log, &default=DISK, &optional; } &optional; uid_map:table[count] of string &optional; pipe_map:table[count] of string &optional; recent_files:set[string] &default=set(), &optional, &read_expire=3.0 mins; } &optional; smtp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; } &optional; smtp_state:record { helo:string &optional; messages_transferred:count &default=0, &optional; pending_messages:set[record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; helo:string &log, &optional; mailfrom:string &log, &optional; rcptto:set[string] &log, &optional; date:string &log, &optional; from:string &log, &optional; to:set[string] &log, &optional; cc:set[string] &log, &optional; reply_to:string &log, &optional; msg_id:string &log, &optional; in_reply_to:string &log, &optional; subject:string &log, &optional; x_originating_ip:addr &log, &optional; first_received:string &log, &optional; second_received:string &log, &optional; last_reply:string &log, &optional; path:vector of addr &log, &optional; user_agent:string &log, &optional; tls:bool &log, &default=F, &optional; process_received_from:bool &default=T, &optional; has_client_activity:bool &default=F, &optional; process_smtp_headers:bool &default=T, &optional; entity_count:count &default=0, &optional; entity:record { filename:string &optional; } &optional; fuids:vector of string &log, &default=vector(), &optional; is_webmail:bool &log, &default=F, &optional; }] &optional; mime_depth:count &default=0, &optional; } &optional; socks:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log; user:string &log, &optional; password:string &log, &optional; status:string &log, &optional; request:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; request_p:port &log, &optional; bound:record { host:addr &optional, &log; name:string &optional, &log; } &log, &optional; bound_p:port &log, &optional; capture_password:bool &default=SOCKS::default_capture_password, &optional; } &optional; ssh:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; version:count &log, &optional; auth_success:bool &log, &optional; auth_attempts:count &log, &default=0, &optional; direction:enum Direction &log, &optional; client:string &log, &optional; server:string &log, &optional; cipher_alg:string &log, &optional; mac_alg:string &log, &optional; compression_alg:string &log, &optional; kex_alg:string &log, &optional; host_key_alg:string &log, &optional; host_key:string &log, &optional; logged:bool &default=F, &optional; capabilities:record { kex_algorithms:vector of string; server_host_key_algorithms:vector of string; encryption_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; mac_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; compression_algorithms:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; }; languages:record { client_to_server:vector of string &optional; server_to_client:vector of string &optional; } &optional; is_server:bool; } &optional; analyzer_id:count &optional; } &optional; syslog:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; proto:enum transport_proto &log; facility:string &log; severity:string &log; message:string &log; } &optional; ja3fp:record { client_version:count &default=0, &optional, &log; client_ciphers:string &default=, &optional, &log; extensions:string &default=, &optional, &log; e_curves:string &default=, &optional, &log; ec_point_fmt:string &default=, &optional, &log; } &optional; ja3sfp:record { server_version:count &default=0, &optional, &log; server_cipher:count &default=0, &optional, &log; server_extensions:string &default=, &optional, &log; server_name:string &default=, &optional, &log; } &optional; } &optional; last_active:time; seen_bytes:count &default=0, &optional; total_bytes:count &optional; missing_bytes:count &default=0, &optional; overflow_bytes:count &default=0, &optional; timeout_interval:interval &default=default_file_timeout_interval, &optional; bof_buffer_size:count &default=default_file_bof_buffer_size, &optional; bof_buffer:string &optional; info:record { ts:time &log; fuid:string &log; tx_hosts:set[addr] &default=set(), &optional, &log; rx_hosts:set[addr] &default=set(), &optional, &log; conn_uids:set[string] &default=set(), &optional, &log; source:string &log, &optional; depth:count &default=0, &optional, &log; analyzers:set[string] &default=set(), &optional, &log; mime_type:string &log, &optional; filename:string &log, &optional; duration:interval &log, &default=0 secs, &optional; local_orig:bool &log, &optional; is_orig:bool &log, &optional; seen_bytes:count &log, &default=0, &optional; total_bytes:count &log, &optional; missing_bytes:count &log, &default=0, &optional; overflow_bytes:count &log, &default=0, &optional; timedout:bool &log, &default=F, &optional; parent_fuid:string &log, &optional; md5:string &log, &optional; sha1:string &log, &optional; sha256:string &log, &optional; x509:record { ts:time &log; fingerprint:string &log; certificate:record { version:count &log; serial:string &log; subject:string &log; issuer:string &log; cn:string &optional; not_valid_before:time &log; not_valid_after:time &log; key_alg:string &log; sig_alg:string &log; key_type:string &optional, &log; key_length:count &optional, &log; exponent:string &optional, &log; curve:string &optional, &log; } &log; handle:opaque of x509; extensions:vector of record { name:string; short_name:string &optional; oid:string; critical:bool; value:string; } &default=vector(), &optional; san:record { dns:vector of string &optional, &log; uri:vector of string &optional, &log; email:vector of string &optional, &log; ip:vector of addr &optional, &log; other_fields:bool; } &optional, &log; basic_constraints:record { ca:bool &log; path_len:count &optional, &log; } &optional, &log; extensions_cache:vector of any &default=vector(), &optional; host_cert:bool &log, &default=F, &optional; client_cert:bool &log, &default=F, &optional; deduplication_index:record { fingerprint:string; host_cert:bool; client_cert:bool; } &optional; } &optional; extracted:string &optional, &log; extracted_cutoff:bool &optional, &log; extracted_size:count &optional, &log; } &optional; ftp:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; user:string &log, &default=<unknown>, &optional; password:string &log, &optional; command:string &log, &optional; arg:string &log, &optional; mime_type:string &log, &optional; file_size:count &log, &optional; reply_code:count &log, &optional; reply_msg:string &log, &optional; data_channel:record { passive:bool &log; orig_h:addr &log; resp_h:addr &log; resp_p:port &log; } &log, &optional; cwd:string &default=., &optional; cmdarg:record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; } &optional; pending_commands:table[count] of record { ts:time; cmd:string &default=<unknown>, &optional; arg:string &default=, &optional; seq:count &default=0, &optional; }; passive:bool &default=F, &optional; capture_password:bool &default=FTP::default_capture_password, &optional; fuid:string &optional, &log; last_auth_requested:string &optional; } &optional; http:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; trans_depth:count &log; method:string &log, &optional; host:string &log, &optional; uri:string &log, &optional; referrer:string &log, &optional; version:string &log, &optional; user_agent:string &log, &optional; origin:string &log, &optional; request_body_len:count &log, &default=0, &optional; response_body_len:count &log, &default=0, &optional; status_code:count &log, &optional; status_msg:string &log, &optional; info_code:count &log, &optional; info_msg:string &log, &optional; tags:set[enum HTTP::Tags] &log; username:string &log, &optional; password:string &log, &optional; capture_password:bool &default=HTTP::default_capture_password, &optional; proxied:set[string] &log, &optional; range_request:bool &default=F, &optional; orig_fuids:vector of string &log, &optional; orig_filenames:vector of string &log, &optional; orig_mime_types:vector of string &log, &optional; resp_fuids:vector of string &log, &optional; resp_filenames:vector of string &log, &optional; resp_mime_types:vector of string &log, &optional; current_entity:record { filename:string &optional; } &optional; orig_mime_depth:count &default=0, &optional; resp_mime_depth:count &default=0, &optional; cookie:string &optional, &log; server_cookie:string &optional, &log; server_date:string &optional, &log; client_lang:string &optional, &log; client_date:string &optional, &log; authorization:string &optional, &log; client_content_type:string &optional, &log; client_dnt:bool &optional, &log; } &optional; irc:record { ts:time &log; uid:string &log; id:record { orig_h:addr &log; orig_p:port &log; resp_h:addr &log; resp_p:port &log; } &log; nick:string &log, &optional; user:string &log, &optional; command:string &log, &optional; value:string &log, &optional; addl:string &log, &optional; dcc_file_name:string &log, &optional; dcc_file_size:count &log, &optional; dcc_mime_type:string &log, &optional; fuid:string &log, &optional; } &optional; pe:record { ts:time &log; id:string &log; machine:string &log, &optional; compile_ts:time &log, &optional; os:string &log, &optional; subsystem:string &log, &optional; is_exe:bool &log, &default=T, &optional; is_64bit:bool &log, &default=T, &optional; uses_aslr:bool &log, &default=F, &optional; uses_dep:bool &log, &default=F, &optional; uses_code_integrity:bool &log, &default=F, &optional; uses_seh:bool &log, &default=T, &optional; has_import_table:bool &log, &optional; has_export_table:bool &log, &optional; has_cert_table:bool &log, &optional; has_debug_data:bool &log, &optional; section_names:vector of string &log, &optional; } &optional; } &optional; fuid:string &log, &optional; file_mime_type:string &log, &optional; file_desc:string &log, &optional; proto:enum transport_proto &log, &optional; note:enum Notice::Type &log; msg:string &log, &optional; sub:string &log, &optional; src:addr &log, &optional; dst:addr &log, &optional; p:port &log, &optional; n:count &log, &optional; peer_name:string &optional; peer_descr:string &log, &optional; actions:set[enum Notice::Action] &log, &default=set(), &optional; email_dest:set[string] &log, &default=(coerce set() to set[string]), &optional; email_body_sections:vector of string &optional; email_delay_tokens:set[string] &optional; identifier:string &optional; suppress_for:interval &log, &default=Notice::default_suppression_interval, &optional; remote_location:record { country_code:string &optional, &log; region:string &optional, &log; city:string &optional, &log; latitude:double &optional, &log; longitude:double &optional, &log; } &log, &optional; }));\x0a}, epoch_result=<uninitialized>, epoch_finished=<uninitialized>]

1626478462.435507 zeek_done
1626478462.435507 ChecksumOffloading::check
